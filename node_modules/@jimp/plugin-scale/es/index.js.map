{"version":3,"sources":["../src/index.js"],"names":["isNodePattern","throwError","scale","f","mode","cb","call","w","bitmap","width","h","height","resize","scaleToFit"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,UAAxB,QAA0C,aAA1C;AAEA,gBAAe;AAAA,SAAO;AACpB;;;;;;;AAOAC,IAAAA,KARoB,iBAQdC,CARc,EAQXC,IARW,EAQLC,EARK,EAQD;AACjB,UAAI,OAAOF,CAAP,KAAa,QAAjB,EAA2B;AACzB,eAAOF,UAAU,CAACK,IAAX,CAAgB,IAAhB,EAAsB,oBAAtB,EAA4CD,EAA5C,CAAP;AACD;;AAED,UAAIF,CAAC,GAAG,CAAR,EAAW;AACT,eAAOF,UAAU,CAACK,IAAX,CAAgB,IAAhB,EAAsB,6BAAtB,EAAqDD,EAArD,CAAP;AACD;;AAED,UAAI,OAAOD,IAAP,KAAgB,UAAhB,IAA8B,OAAOC,EAAP,KAAc,WAAhD,EAA6D;AAC3DA,QAAAA,EAAE,GAAGD,IAAL;AACAA,QAAAA,IAAI,GAAG,IAAP;AACD;;AAED,UAAMG,CAAC,GAAG,KAAKC,MAAL,CAAYC,KAAZ,GAAoBN,CAA9B;AACA,UAAMO,CAAC,GAAG,KAAKF,MAAL,CAAYG,MAAZ,GAAqBR,CAA/B;AACA,WAAKS,MAAL,CAAYL,CAAZ,EAAeG,CAAf,EAAkBN,IAAlB;;AAEA,UAAIJ,aAAa,CAACK,EAAD,CAAjB,EAAuB;AACrBA,QAAAA,EAAE,CAACC,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACD;;AAED,aAAO,IAAP;AACD,KA/BmB;;AAiCpB;;;;;;;;AAQAO,IAAAA,UAzCoB,sBAyCTN,CAzCS,EAyCNG,CAzCM,EAyCHN,IAzCG,EAyCGC,EAzCH,EAyCO;AACzB,UAAI,OAAOE,CAAP,KAAa,QAAb,IAAyB,OAAOG,CAAP,KAAa,QAA1C,EAAoD;AAClD,eAAOT,UAAU,CAACK,IAAX,CAAgB,IAAhB,EAAsB,yBAAtB,EAAiDD,EAAjD,CAAP;AACD;;AAED,UAAI,OAAOD,IAAP,KAAgB,UAAhB,IAA8B,OAAOC,EAAP,KAAc,WAAhD,EAA6D;AAC3DA,QAAAA,EAAE,GAAGD,IAAL;AACAA,QAAAA,IAAI,GAAG,IAAP;AACD;;AAED,UAAMD,CAAC,GACLI,CAAC,GAAGG,CAAJ,GAAQ,KAAKF,MAAL,CAAYC,KAAZ,GAAoB,KAAKD,MAAL,CAAYG,MAAxC,GACID,CAAC,GAAG,KAAKF,MAAL,CAAYG,MADpB,GAEIJ,CAAC,GAAG,KAAKC,MAAL,CAAYC,KAHtB;AAIA,WAAKP,KAAL,CAAWC,CAAX,EAAcC,IAAd;;AAEA,UAAIJ,aAAa,CAACK,EAAD,CAAjB,EAAuB;AACrBA,QAAAA,EAAE,CAACC,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACD;;AAED,aAAO,IAAP;AACD;AA9DmB,GAAP;AAAA,CAAf","sourcesContent":["import { isNodePattern, throwError } from '@jimp/utils';\n\nexport default () => ({\n  /**\n   * Uniformly scales the image by a factor.\n   * @param {number} f the factor to scale the image by\n   * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  scale(f, mode, cb) {\n    if (typeof f !== 'number') {\n      return throwError.call(this, 'f must be a number', cb);\n    }\n\n    if (f < 0) {\n      return throwError.call(this, 'f must be a positive number', cb);\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n      cb = mode;\n      mode = null;\n    }\n\n    const w = this.bitmap.width * f;\n    const h = this.bitmap.height * f;\n    this.resize(w, h, mode);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Scale the image to the largest size that fits inside the rectangle that has the given width and height.\n   * @param {number} w the width to resize the image to\n   * @param {number} h the height to resize the image to\n   * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  scaleToFit(w, h, mode, cb) {\n    if (typeof w !== 'number' || typeof h !== 'number') {\n      return throwError.call(this, 'w and h must be numbers', cb);\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n      cb = mode;\n      mode = null;\n    }\n\n    const f =\n      w / h > this.bitmap.width / this.bitmap.height\n        ? h / this.bitmap.height\n        : w / this.bitmap.width;\n    this.scale(f, mode);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"],"file":"index.js"}